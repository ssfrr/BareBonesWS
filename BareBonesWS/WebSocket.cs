// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Threading;

namespace BareBonesWS
{
	public delegate void OnMsgDelegate(string msg);

	public class WebSocket
	{
		public string Path {get; set;}
		public string Host {get; set;}
		public OnMsgDelegate OnMessage;
		NetworkStream NetStream;
		TcpClient Sock;
		StreamReader Reader;
		StreamWriter Writer;
		BinaryReader BinReader;
		Thread ListenerThread;
		volatile bool ShouldStop;
		const string HANDSHAKE = "GET {0} HTTP/1.1\r\n" +
				"Host: {1}\r\n" +
				"Upgrade: websocket\r\n" +
				"Connection: Upgrade\r\n" +
				"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n" +
				"Sec-WebSocket-Version: 13\r\n" +
				"\r\n";


		public WebSocket(string uriString)  {
			UriBuilder uri = new UriBuilder(uriString);
			Path = uri.Path;
			Host = uri.Host;
			Sock = new TcpClient(uri.Host, 80);
			NetStream = Sock.GetStream();
			Reader = new StreamReader(NetStream);
			Writer = new StreamWriter(NetStream);
			BinReader = new BinaryReader(NetStream);
			Writer.AutoFlush = true;
			ShouldStop = false;
			ListenerThread = new Thread(ListenerFunc);

			SendHandshake(Writer, Host, Path);
			ReadHandshakeResponse(Reader);
		}

		~WebSocket() {
			Close();
		}

		void ListenerFunc() {
			while(!ShouldStop) {
				string msg = ReadMessage();
				OnMessage(msg);
			}
		}

		public void SpawnListener() {
			if(ListenerThread.IsAlive) {
				Console.WriteLine("Tried to double-spawn listener thread");
				return;
			}
			ShouldStop = false;
			ListenerThread.Start();
		}

		public void StopListener() {
			if(!ListenerThread.IsAlive) {
				Console.WriteLine("Tried to stop a non-running listener thread");
				return;
			}
			ShouldStop = true;
			ListenerThread.Join();
		}

		public void Close() {
			if(ListenerThread.IsAlive) {
				StopListener();
			}
			if(NetStream != null) {
				NetStream.Close();
				NetStream = null;
			}
			if(Sock != null) {
				Sock.Close();
				Sock = null;
			}
			if(Reader != null) {
				Reader.Close();
				Reader = null;
			}
			if(Writer != null) {
				Writer.Close();
				Writer = null;
			}
			if(BinReader != null) {
				BinReader.Close();
				BinReader = null;
			}
		}

		void SendHandshake(StreamWriter writer, string host, string path) {
			writer.Write(String.Format(HANDSHAKE, path, host));
		}

		string ReadHandshakeResponse(StreamReader reader) {
			string resp = reader.ReadLine();
			while(resp != "") {
				resp = reader.ReadLine();
			}
			return resp;
		}

		public string ReadMessage() {
			byte[] header = new byte[2];
			int bytesRead = BinReader.Read(header, 0, 2);
			if(bytesRead != 2) {
				Console.WriteLine("Only read {0} bytes for header", bytesRead);
				return "";
			}
			int msgLen = header[1] & 0x7f;
			if(msgLen == 126) {
				byte[] msgLenBytes = new byte[2];
				bytesRead = BinReader.Read(msgLenBytes, 0, 2);
				if(bytesRead != 2) {
					Console.WriteLine("Only read {0} bytes of 2-byte length", bytesRead);
					return "";
				}
				if(BitConverter.IsLittleEndian) {
					Array.Reverse(msgLenBytes);
				}
				msgLen = BitConverter.ToUInt16(msgLenBytes, 0);
			}
			else if(msgLen == 127) {
				Console.WriteLine("Can't currently handle 8-byte lengths");
				return "";
			}

			char[] msg = new char[msgLen];
			bytesRead = BinReader.Read(msg, 0, msgLen);
			if(bytesRead != msgLen) {
				Console.WriteLine("Only read {0} bytes from {1}-byte msg", bytesRead, msgLen);
				return "";
			}
			return new string(msg);
		}
	}
}

